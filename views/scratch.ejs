<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆ®åˆ®å¡</title>
    <link rel="stylesheet" href="/styles.css">
    <style>
        body {
            background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)), 
                        radial-gradient(circle at center, #667eea 0%, #764ba2 100%);
            color: #fff;
        }
        
        .board {
            max-width: 750px;
            margin: auto;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 1.5rem;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .labels {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: bold;
        }
        
        #scratchContainer {
            position: relative;
            width: 100%;
            aspect-ratio: 5 / 4;
            background: #eee;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
        }
        
        #scratchCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        #scratchContent {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            font-weight: bold;
            font-size: 1rem;
            color: #000;
        }
        
        .grid-item {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(0,0,0,0.1);
            background: #fff;
        }
        
        .scratch-ui {
            margin-top: 1.5rem;
            position: relative;
            z-index: 10;
        }
        
        button {
            padding: 0.8rem 1.5rem;
            background: #ffcc00;
            color: #000;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 0.5rem;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #ffd700;
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }
        
        #verifyResult {
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <a href="/" class="back-button">â† è¿”å›</a>
    <div class="game-container">
        <div class="board">
            <h2>ğŸ¯ åˆ®åˆ®å¡</h2>
            <p>ç©å®¶ï¼š<%= username %></p>
            <div class="labels">åˆ®å¼€æ ¼å­ï¼Œæ‰¾åˆ°åŒ¹é…çš„ä¸­å¥–å·ç ï¼</div>
            <div id="scratchContainer">
                <div id="scratchContent"></div>
                <canvas id="scratchCanvas"></canvas>
            </div>

            <div class="scratch-ui">
                <button onclick="startScratch()">å¼€å§‹åˆ®å¥–</button>
                <button onclick="verifyWin()">ğŸ¯ éªŒè¯ç»“æœ</button>
                <p id="verifyResult" style="font-weight: bold; font-size: 1.2rem;"></p>
            </div>
        </div>
    </div>

    <script>
        const username = "<%= username %>";
        
        // Polyfill for crypto.randomUUID
        if (!crypto.randomUUID) {
            crypto.randomUUID = function () {
                return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
                    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                );
            };
        }
        
        let hasVerified = true;
        
        function createCard(num, prize) {
            const cell = document.createElement('div');
            cell.className = 'grid-item';
            cell.innerHTML = `<div>${num}</div><div>${prize || ''}</div>`;
            return cell;
        }
        
        async function startScratch() {
            if (!hasVerified) {
                alert('è¯·å…ˆéªŒè¯å½“å‰ç»“æœï¼Œå†å¼€å§‹ä¸‹ä¸€è½®åˆ®å¥–ï¼');
                return;
            }
            hasVerified = false;
            
            // åˆå§‹åŒ–Canvasé®ç½©å±‚ - é˜²æ­¢æ•°å­—é—ªç°
            const canvas = document.getElementById('scratchCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // åˆ›å»ºé“¶è‰²é®ç½©å±‚
            ctx.fillStyle = '#c0c0c0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ·»åŠ çº¹ç†æ•ˆæœ
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${160 + Math.random() * 80}, ${160 + Math.random() * 80}, ${160 + Math.random() * 80}, 0.3)`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 5, 5);
            }
            
            ctx.globalCompositeOperation = 'destination-out';
            
            // è¯·æ±‚æ•°æ®
            const timestamp = Math.floor(Date.now() / 1000);
            const nonce = crypto.randomUUID();
            
            try {
                const res = await fetch('/api/scratch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, timestamp, nonce })
                });
                
                const data = await res.json();
                if (!data.success) {
                    alert('âŒ ' + data.message);
                    return;
                }
                
                const all = [
                    ...data.winningNumbers.map(n => ({ num: n, amount: 'ä¸­å¥–å·ç ', prize: 'ä¸­å¥–å·ç ' })),
                    ...data.slots
                ];
                
                const container = document.getElementById('scratchContent');
                container.innerHTML = '';
                all.forEach(({ num, amount, prize }) => container.appendChild(createCard(num, amount || prize)));
                
                // åˆ®åˆ®é€»è¾‘ - å®Œå…¨æŒ‰ç…§åŸç‰ˆ
                let isDrawing = false, lastX = null, lastY = null;
                
                // é¼ æ ‡äº‹ä»¶
                canvas.onmousedown = (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    lastX = e.clientX - rect.left;
                    lastY = e.clientY - rect.top;
                    drawAt(lastX, lastY);
                };
                
                canvas.onmouseup = canvas.onmouseleave = () => {
                    isDrawing = false;
                    lastX = lastY = null;
                };
                
                canvas.onmousemove = e => {
                    if (!isDrawing) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    drawAt(x, y);
                };
                
                // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
                canvas.ontouchstart = e => {
                    isDrawing = true;
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    lastX = touch.clientX - rect.left;
                    lastY = touch.clientY - rect.top;
                    drawAt(lastX, lastY);
                };
                
                canvas.ontouchmove = e => {
                    if (!isDrawing) return;
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    drawAt(x, y);
                };
                
                canvas.ontouchend = () => {
                    isDrawing = false;
                    lastX = lastY = null;
                };
                
                // ç»˜åˆ¶å‡½æ•°
                function drawAt(x, y) {
                    if (lastX !== null && lastY !== null) {
                        const dx = x - lastX;
                        const dy = y - lastY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const steps = Math.ceil(dist / 4);
                        for (let i = 0; i <= steps; i++) {
                            const lerpX = lastX + (dx * i / steps);
                            const lerpY = lastY + (dy * i / steps);
                            ctx.beginPath();
                            ctx.arc(lerpX, lerpY, 20, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    lastX = x;
                    lastY = y;
                }
                
                document.getElementById('verifyResult').textContent = '';
                
            } catch (error) {
                alert('ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•');
                console.error('Error:', error);
            }
        }
        
        function verifyWin() {
            const grid = Array.from(document.querySelectorAll('#scratchContent .grid-item'));
            const winNums = grid.slice(0, 5).map(cell => parseInt(cell.children[0].textContent));
            const userSlots = grid.slice(5);
            
            const matched = [];
            
            userSlots.forEach(cell => {
                const num = parseInt(cell.children[0].textContent);
                const amount = cell.children[1].textContent;
                if (winNums.includes(num) && amount !== '0') {
                    matched.push({ num, amount });
                }
            });
            
            const result = document.getElementById('verifyResult');
            if (matched.length > 0) {
                const totalAmount = matched.reduce((sum, m) => {
                    const amt = parseInt(m.amount.replace('+', ''));
                    return sum + (isNaN(amt) ? 0 : amt);
                }, 0);
                result.textContent = `ğŸ‰ æ­å–œä¸­å¥–ï¼æ€»é‡‘é¢ï¼š+${totalAmount}`;
                result.style.color = '#00ff88';
            } else {
                result.textContent = 'ğŸ˜¢ å¾ˆé—æ†¾ï¼Œè¿™æ¬¡æ²¡æœ‰ä¸­å¥–ã€‚å†è¯•ä¸€æ¬¡ï¼';
                result.style.color = '#ff5555';
            }
            
            hasVerified = true;
        }
    </script>
</body>
</html>